#include <assert.h>
#include <inttypes.h>
#define _USE_MATH_DEFINES
#include <math.h>
#include <stdint.h>
#include <stdio.h>

#include "bedrock/bedrock.h"

#include "config.h"
#include "messages.h"
#include "tiles/tiles.h"

typedef struct {
  double timing;
  double since_update;

  Tiles *tiles;
} SceneTest;

uint8_t map[40 * 30] = {
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 96, 96, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 32, 32, 32, 96, 96, 96, 32, 32, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 32, 32, 32, 32, 32, 96, 96, 32, 96, 32, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 32, 32, 32, 32, 32, 96, 32, 32, 32, 96, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 32, 32, 32, 32, 32, 32, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 32, 32, 32, 32, 96, 96, 32, 32, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 32, 32, 32, 32, 32, 32, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 32, 32, 96, 96, 32, 32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
};

typedef struct {
  uint8_t offset;
  uint8_t neighbors[9];
} AutoTile;
// TODO: Sort by filter order, diagonal checks first then optional diagonals after
AutoTile auto_tiles[] = {
  {
    .offset = 64,
    .neighbors = {
      0, 0, 0, 0, 0, 0, 0, 0, 0,
    },
  },
  // Internal corners
  {
    .offset = 19,
    .neighbors = {
      1, 1, 1, 1, 1, 1, 1, 1, 0,
    },
  },
  {
    .offset = 20,
    .neighbors = {
      1, 1, 1, 1, 1, 1, 0, 1, 1,
    },
  },
  {
    .offset = 35,
    .neighbors = {
      1, 1, 0, 1, 1, 1, 1, 1, 1,
    },
  },
  {
    .offset = 36,
    .neighbors = {
      0, 1, 1, 1, 1, 1, 1, 1, 1,
    },
  },
  // Connections
  {
    .offset = 7,
    .neighbors = {
      0, 1, 0, 1, 1, 1, 1, 1, 1,
    },
  },
  {
    .offset = 22,
    .neighbors = {
      1, 1, 0, 1, 1, 1, 1, 1, 0,
    },
  },
  {
    .offset = 38,
    .neighbors = {
      1, 1, 1, 1, 1, 1, 0, 1, 0,
    },
  },
  {
    .offset = 54,
    .neighbors = {
      0, 1, 1, 1, 1, 1, 0, 1, 1,
    },
  },
  // External box
  {
    .offset = 16,
    .neighbors = {
      '*', 0, '*', 0, 1, 1, '*', 1, 1,
    },
  },
  {
    .offset = 17,
    .neighbors = {
      '*', 0, '*', 1, 1, 1, 1, 1, 1,
    },
  },
  {
    .offset = 18,
    .neighbors = {
      '*', 0, '*', 1, 1, 0, 1, 1, '*',
    },
  },
  {
    .offset = 32,
    .neighbors = {
      '*', 1, 1, 0, 1, 1, '*', 1, 1,
    },
  },
  {
    .offset = 33,
    .neighbors = {
      1, 1, 1, 1, 1, 1, 1, 1, 1,
    },
  },
  {
    .offset = 34,
    .neighbors = {
      1, 1, '*', 1, 1, 0, 1, 1, '*',
    },
  },
  {
    .offset = 48,
    .neighbors = {
      '*', 1, 1, 0, 1, 1, '*', 0, '*',
    },
  },
  {
    .offset = 49,
    .neighbors = {
      1, 1, 1, 1, 1, 1, '*', 0, '*',
    },
  },
  {
    .offset = 50,
    .neighbors = {
      1, 1, '*', 1, 1, 0, '*', 0, '*',
    },
  },
  // Thin
  {
    .offset = 0,
    .neighbors = {
      '*', 0, '*', 1, 1, 0, '*', 1, '*',
    },
  },
  {
    .offset = 1,
    .neighbors = {
      '*', 1, '*', 1, 1, 0, '*', 0, '*',
    },
  },
  {
    .offset = 2,
    .neighbors = {
      '*', 1, '*', 0, 1, 1, '*', 0, '*',
    },
  },
  {
    .offset = 3,
    .neighbors = {
      '*', 0, '*', 0, 1, 1, '*', 1, '*',
    },
  },
  {
    .offset = 4,
    .neighbors = {
      '*', 1, '*', 0, 1, 0, '*', 1, '*',
    },
  },
  {
    .offset = 5,
    .neighbors = {
      '*', 0, '*', 1, 1, 1, '*', 0, '*',
    },
  },
  {
    .offset = 21,
    .neighbors = {
      '*', 1, '*', 0, 1, 1, '*', 1, '*',
    },
  },
  {
    .offset = 23,
    .neighbors = {
      '*', 0, '*', 0, 1, 0, '*', 0, '*',
    },
  },
  {
    .offset = 24,
    .neighbors = {
      '*', 0, '*', 1, 1, 0, '*', 0, '*',
    },
  },
  {
    .offset = 39,
    .neighbors = {
      '*', 0, '*', 0, 1, 0, '*', 1, '*',
    },
  },
  {
    .offset = 55,
    .neighbors = {
      '*', 1, '*', 0, 1, 0, '*', 0, '*',
    },
  },
};
uintmax_t num_auto_tiles = 29;

SceneTest *scene_test3_create(const Config *config) {
  SceneTest *scene = calloc(1, sizeof(SceneTest));

  scene->timing = 1 / 30.0;
  scene->since_update = scene->timing;

  scene->tiles = tiles_create(config->res_width, config->res_height, 40, 30);
  for (uintmax_t y = 0; y < 30; y++) {
    for (uintmax_t x = 0; x < 40; x++) {
      uintmax_t index = (y * 40) + x;
      if (map[index] == 0) {
        continue;
      }
      uint8_t tile = map[index];

      // Find neighbors
      uint8_t neighbors[9] = { 0 };
      if (x == 0) {
        neighbors[0] = 1;
        neighbors[3] = 1;
        neighbors[6] = 1;
      }
      if (y == 0) {
        neighbors[0] = 1;
        neighbors[1] = 1;
        neighbors[2] = 1;
      }
      if (x == 39) {
        neighbors[2] = 1;
        neighbors[5] = 1;
        neighbors[8] = 1;
      }
      if (y == 29) {
        neighbors[6] = 1;
        neighbors[7] = 1;
        neighbors[8] = 1;
      }
      for (intmax_t yy = (y == 0 ? 0 : -1); yy <= (y == 29 ? 0 : 1); yy++) {
        for (intmax_t xx = (x == 0 ? 0 : -1); xx <= (x == 39 ? 0 : 1); xx++) {
          uintmax_t t_index = ((y + yy) * 40) + (x + xx);
          uintmax_t n_index = ((yy + 1) * 3) + (xx + 1);
          neighbors[n_index] = (map[t_index] == tile ? 1 : 0);
        }
      }

      // Find offset
      uint8_t offset = 0;
      for (uintmax_t t = 0; t < num_auto_tiles; t++) {
        bool skip = false;
        for (uintmax_t n = 0; n < 9; n++) {
          if (auto_tiles[t].neighbors[n] != '*' && auto_tiles[t].neighbors[n] != neighbors[n]) {
            skip = true;
            break;
          }
        }
        if (!skip) {
          offset = auto_tiles[t].offset;
          break;
        }
      }
      if (offset == 0) {
        printf("%d %d %d\n", neighbors[0], neighbors[1], neighbors[2]);
        printf("%d %d %d\n", neighbors[3], neighbors[4], neighbors[5]);
        printf("%d %d %d\n\n", neighbors[6], neighbors[7], neighbors[8]);
      }

      scene->tiles->tilemap[index] = map[index] + offset;
    }
  }

  return scene;
}

void scene_test3_destroy(SceneTest *scene) {
  assert(scene);

  tiles_destroy(scene->tiles);

  free(scene);
}

void scene_test3_update(SceneTest *scene, double delta) {
  assert(scene);

  scene->since_update += delta;
  while (scene->since_update >= scene->timing) {
    scene->since_update -= scene->timing;
  }
}

void scene_test3_draw(SceneTest *scene) {
  assert(scene);

  tiles_draw(scene->tiles);
}
